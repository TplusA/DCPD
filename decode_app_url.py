#! /usr/bin/env python3
#
# Script for decoding URLs passed from App to ARM through tunnel:
# - Find hexdump in log file or stdin (start line and maximum number of lines
#   can be specified).
# - Take fraction of hexdump the URL is expected to be found (byte offset can
#   be specified).
# - Decode it by XOR'ing each input byte with a number generated by a
#   linear-feedback shift register PRNG.
#
# --------------------------------------------------------------------------
#
# FAQ:
#
# * Why is the default byte offset for decoding URLs set to 16?
#
#   Because the concealed URLs are sent through the TCP tunnel, and tunnel
#   traffic is packed into DCP packets. Each DCP packet containing TCP traffic
#   starts with a 4 byte header (0x02 0x78 followed by two bytes for the size),
#   and a 3 byte header for the TCP tunnel register (two bytes for the TCP port
#   number and one bytes for the peer ID). So far, that's 7 bytes.
#
#   The tunnel header is followed by raw data sent by the TCP peer. This peer
#   and the appliance CPU have a protocol of their own, and in case of URLs,
#   the protocol header will be 9 bytes long.
#
#   And 7 plus 9 equals 16.
#
# * How about URLs exceeding the size of a DCP packet?
#
#   The TCP peer just sends a stream of protocol data, and the tunnel code on
#   the Streaming Board is responsible for packing this stream into chunks
#   suitable for DCP. DCP payloads cannot exceed 256 bytes, meaning up to 253
#   bytes of raw TCP data per packet (256 minus 3 bytes for tunnel overhead).
#   Each packet will have an overhead of 7 bytes, except for the first packet,
#   which will usually have 16 bytes of overhead because of the encapsulated
#   protocol overhead.
#
#   Therefore, to decode a long URL spanning several DCP packets, follow these
#   steps:
#
#   1. Paste all related hexdumps one after the other, preserving their order.
#   2. Remove the first 7 bytes from each hexdump, starting with the second
#      hexdump (option -b will take care of the first hexdump). It is OK for
#      lines to contain fewer than 16 bytes of data. Watch for 0x27 escape
#      sequences!
#   3. Fix up the offset column in the hexdump. This script will print an error
#      in case the offsets are wrong to guide this process.
#
# * In which case would it ever be necessary to set the start byte to a value
#   different from 16?
#
#   First, the TCP tunnel data is really a continuous stream. It is entirely
#   possible for the URL command not to occur at the beginning of the dump,
#   following the trailing bytes of a preceding command. The correct byte
#   offset would have to be found by manual protocol inspection.
#
#   Second, the hexdump may not come from the dcpspi log, but from some other
#   higher-level application which just sees the TCP data stream. In this case,
#   there would certainly be neither a DCP header nor the TCP tunnel header. A
#   better guess for the start offset would be 9 in this case.
#
# * Decoding starts off OK but then suddenly produces binary junk. Why?
#
#   Try option -u to unescape SPI escape sequences. The Streaming Board logs
#   from dcpspi show what's sent over the wire, hence the escape sequences are
#   included.
#
# * There is binary junk after the nul terminator following the URL. Why?
#
#   The URL string is followed by 2 checksum bytes stemming from the
#   encapsulated protocol. Since this script doesn't know anything about this
#   protocol, these two bytes are decoded as well and written to the output. In
#   case the URL command is followed by another command in the TCP stream, this
#   data is decoded as well. Use option -n to mitigate this effect.
#
#   In case the output of this script is piped to hexdump to analyze any binary
#   garbage, please note that this script will append a 0x0a byte (newline) to
#   the output, and this will show up as last byte in your hexdump as well.
#
# --------------------------------------------------------------------------

import sys
import getopt
import re

class LFSR:
    def __init__(self, seed, mask):
        self.mask = mask
        self.default_seed = seed
        self.reset()

    def reset(self):
        self.state = self.default_seed

    def get_byte(self):
        lsb = self.state & 1
        self.state >>= 1

        if lsb:
            self.state ^= self.mask

        return self.state & 0xff

class Hexdump:
    def __init__(self, offset = 0):
        self.offset = offset
        self.data = []

    def add_chunk(self, offset, data):
        if offset != self.offset + len(self.data):
            raise IndexError("Hexdump offset does not match; expected {}, got {}".format(self.offset + len(self.data), offset))

        self.data += data

def extract_hexdump(input, start_line, max_lines):
    while start_line > 1:
        input.readline()
        start_line = start_line - 1

    if not max_lines:
        lines = input.readlines()
    else:
        lines = []

        while max_lines > 0:
            lines.append(input.readline())
            max_lines = max_lines - 1

    hexdump = None

    for l in lines:
        m = re.search(r'([\da-f]{4})  ([\da-f]{2} ( *[\da-f]{2})*) *  \|', l)

        if not m:
            continue

        offset = int(m.group(1).strip(), 16)

        if hexdump == None:
            hexdump = Hexdump(offset)

        try:
            hexdump.add_chunk(offset, list(map(lambda x: int(x, 16), re.split(r' +', m.group(2).strip()))))
        except:
            print("Failed processing the following line:")
            print(l.strip())
            raise

    return hexdump

def escaped_hexdump(hexdump):
    escaped = Hexdump(hexdump.offset)

    r = iter(range(0, len(hexdump.data)))

    for i in r:
        b = hexdump.data[i]

        if b == 0x27:
            next(r)

            b = hexdump.data[i + 1]

            if b == 0x01:
                b = 0xff

        escaped.data.append(b)

    return escaped

def error_exit(error_message, exit_code = 1):
    print("ERROR: " + error_message, file = sys.stderr)
    sys.exit(exit_code)

def usage(exit_code = 1):
    print("""Usage:
{0} [-h] [-l start line] [-b start byte] [-u] [input file]

Options:
-h       This help screen.
-l line  Which line to begin in searching for a hexdump (default: 1)
-n num   How many lines to read at most (default: all)
-b byte  At which byte in the hexdump decoding should start (default: 16);
         please read the comments at the top of this script for details
-u       Unescape SPI escape sequences (0x27 handling)""".format(sys.argv[0]))
    sys.exit(exit_code)

def main():
    input = sys.stdin
    start_byte = 16
    start_line = 1
    max_lines = None
    unescape = False

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hb:l:n:u")
    except getopt.GetoptError as err:
        error_exit(str(err))

    for o, a in opts:
        if o == "-h":   usage(0)
        elif o == "-b": start_byte = int(a)
        elif o == "-l": start_line = int(a)
        elif o == "-n": max_lines = int(a)
        elif o == "-u": unescape = True

    if args:
        input = open(args[0], "r")

    try:
        hexdump = extract_hexdump(input, start_line, max_lines)

        if unescape:
            hexdump = escaped_hexdump(hexdump)

        prng = LFSR(44257, 46080)
        decoded = ''.join(list(map(lambda x: chr(x ^ prng.get_byte()), hexdump.data[start_byte:])))

        print(decoded)
    except IndexError as err:
        print("Failed processing input: " + str(err))

if __name__ == '__main__':
    main();
